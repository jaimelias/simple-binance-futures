var BinanceFutures;(()=>{var e={262:()=>{}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";r.r(n),r.d(n,{default:()=>a,defaultEndpoints:()=>i});var e=r(262);const t=["time"],o=async({main:e,side:t,entryPrice:r,handleExistingOrders:n})=>{if("string"==typeof n){n=n.toUpperCase();const o=(await e.getOrders()).filter((r=>r.symbol===e.contractName&&"LIMIT"===r.type&&r.side===t&&!1===r.reduceOnly&&!1===r.priceProtect&&!1===r.closePosition&&r.goodTillDate));if(o.length>0){if("KEEP"===n)return e.debug&&console.log(`New order (entryPrice=${r}, side=${t}) not executed. Found existing orders:`,o),!1;if("ERROR"===n)throw Error(`New order (entryPrice=${r}, side=${t}) not executed. Found duplicated orders: ${JSON.stringify(o)}`);if("REPLACE"===n){const t=await e.cancelMultipleOrders(o);e.debug&&console.log("cancelMultipleOrders",t)}else"ADD"===n&&e.debug&&console.log("Existing orders found. Pushing new order without deleting existing orders.")}}return!0},i={testnet:"https://testnet.binancefuture.com",production:"https://fapi.binance.com"};class a{constructor(e,t){(e=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "strategy" must be a non-null object.');if(!e.hasOwnProperty("environment"))throw new Error('Missing "environment" property in strategy object.');if(!["testnet","production"].includes(e.environment))throw new Error('Invalid "environment" property. Only "testnet" and "production" are accepted.');if(!e.hasOwnProperty("contractName"))throw new Error('Missing "contractName" property in strategy object.');if("string"!=typeof e.contractName||!e.contractName.endsWith("USDT"))throw new Error('Invalid "contractName". Only USD-M contracts are supported (e.g., "BTCUSDT").');if(!e.hasOwnProperty("leverage"))throw new Error('Missing "leverage" property in strategy object.');if(e.hasOwnProperty("marginType")&&("string"!=typeof e.marginType||!["ISOLATED","CROSSED"].includes(e.marginType)))throw new Error('Invalid "marginType" property in strategy object. Only "ISOLATED" and "CROSSED" margins are supported.');if(e.hasOwnProperty("useServerTime")&&"boolean"!=typeof e.useServerTime)throw new Error('Invalid "useServerTime" property in strategy object. Only boolean value is accepted');if(e.hasOwnProperty("debug")&&"boolean"!=typeof e.debug)throw new Error('Invalid "debug" property in strategy object. Only boolean value is accepted');const t=e.leverage;if("number"!=typeof t||isNaN(t)||t<=0)throw new Error('Invalid "leverage". It must be a positive number.')})(t);const{contractName:r,leverage:n,marginType:o="ISOLATED",environment:a,debug:s=!1,useServerTime:c=!1}=t;(e=>{if(!["testnet","production"].includes(e))throw new Error('Invalid environment. Allowed values are "testnet" and "production".')})(a),((e,t)=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "credentials" must be a non-null object.');if(!e.hasOwnProperty(t))throw new Error(`Missing credentials for environment: "${t}".`);const r=e[t];if(!r.hasOwnProperty("API_KEY"))throw new Error(`Missing "API_KEY" in credentials for environment "${t}".`);if(!r.hasOwnProperty("API_SECRET"))throw new Error(`Missing "API_SECRET" in credentials for environment "${t}".`)})(e,a);const{API_KEY:p,API_SECRET:d,PROXY:l}=e[a];this.API_KEY=p,this.API_SECRET=d,this.endpoint="string"==typeof l&&l.startsWith("http")?`${l}/fapi`:`${i[a]}/fapi`,this.contractName=r,this.leverage=n,this.marginType=o,this.useServerTime=c,this.environment=a,this.debug=s,this.engine="undefined"!=typeof ScriptApp?"google-app-script":"undefined"!=typeof process&&"node"===process.release?.name?"node":"undefined"!=typeof Deno?"deno":"undefined"!=typeof Bun?"bun":"undefined"!=typeof WebSocketPair?"cloudflare-worker":"unknown",this.cache={}}async fetch(r,n="GET",o={},i="v1"){return await(async(r,n,o,i,a)=>{const s={...i,symbol:r.contractName};if(!t.includes(n)){let e=Date.now();r.useServerTime&&(e=await r.getServerTime()),s.timestamp=e,s.recvWindow=5e3}const c=`${r.endpoint}/${a}/${n}`,p=Object.entries(s).map((([e,t])=>`${e}=${encodeURIComponent(t)}`)).join("&"),d=((t,r)=>{const{engine:n,API_SECRET:o}=t;if("google-app-script"===n)return Utilities.computeHmacSha256Signature(r,o).map((e=>{const t=e+256&255;return(t<16?"0":"")+t.toString(16)})).join("");let i;if("object"==typeof e)i=e;else{if("object"!=typeof t.nodeCrypto)throw new Error('"crypto" library is not available in your global scope. you can pass "crypto" using the property "nodeCrypto" in your strategy');i=t.nodeCrypto}const a=i.createHmac("sha256",o);return a.update(r),a.digest("hex")})(r,p),l=t.includes(n)?p:`${p}&signature=${d}`,u=t.includes(n)?{}:{"X-MBX-APIKEY":r.API_KEY};let y;const f={method:o,headers:u};return"GET"===o||"DELETE"===o?y=`${c}?${l}`:(y=c,u["Content-Type"]="application/x-www-form-urlencoded","google-app-script"===r.engine?(f.payload=l,f.muteHttpExceptions=!0):f.body=l),"google-app-script"===r.engine?await(async(e,t)=>{const r=UrlFetchApp.fetch(e,t),n=r.getResponseCode(),o=r.getContentText();if(200===n)return JSON.parse(o);throw new Error(`Request failed with status ${n}: ${o}`)})(y,f):await(async(e,t,r)=>{let n;if("function"==typeof fetch)n=fetch;else{if("function"!=typeof e.nodeFetch)throw new Error('"fetch" library is not available in your global scope. you can pass "fetch" using the property "nodeFetch" in your strategy');n=e.nodeFetch}const o=await n(t,r),i=o.status,a=await o.text();if(200===i)return JSON.parse(a);throw new Error(`Request failed with status ${i}: ${a}`)})(r,y,f)})(this,r,n,o,i)}async getServerTime(){return(await this.fetch("time","GET",{})).serverTime}async getOrders(){return await this.fetch("openOrders","GET",{})}async getPositions(){return await this.fetch("positionRisk","GET",{},"v3")}async getBalanceInUSDT(e="USDT"){const t=(await this.fetch("balance","GET",{},"v2")).find((t=>t.asset===e));return"object"==typeof t?t.balance:0}async getContractInfo(){const{contractName:e}=this,t=`contract_${e}`;if(this.cache.hasOwnProperty(t))return this.cache[t];const r=(await this.fetch("exchangeInfo","GET",{})).symbols.find((t=>t.symbol===e));if(void 0===r)throw new Error(`contract ${e} not fund`);return this.cache[t]=r,r}async changeLeverage(){return await this.fetch("leverage","POST",{leverage:this.leverage})}async cancelMultipleOrders(e){const t=JSON.stringify(e.map((e=>e.orderId)));return await this.fetch("batchOrders","DELETE",{orderIdList:t})}async cancelOrder(e){const{orderId:t}=e;return await this.fetch("order","DELETE",{orderId:t})}async createLimitOrder({side:e,amountInUSDT:t,entryPrice:r,handleExistingOrders:n,expirationInMinutes:i}){return await(async({main:e,side:t="BUY",amountInUSDT:r,entryPrice:n,handleExistingOrders:i="ADD",expirationInMinutes:a=10})=>{(({side:e,amountInUSDT:t,entryPrice:r,handleExistingOrders:n,expirationInMinutes:o})=>{if(!e||!["BUY","SELL"].includes(e))throw new Error('Invalid or missing property "side" in createLimitOrder.');if("number"!=typeof t||t<=0)throw new Error('Missing or invalid "amountInUSDT" in createLimitOrder. "amountInUSDT" must be a positive number.');if("number"!=typeof r||r<=0)throw new Error('Missing or invalid "entryPrice" in createLimitOrder. "entryPrice" must be a positive number.');if(void 0!==o&&!("number"==typeof o&&o>=10))throw new Error('Invalid "expirationInMinutes" in createLimitOrder. "expirationInMinutes" must be a positive number larger than or equal to 10.');if(!n||!["KEEP","ERROR","REPLACE","ADD"].includes(n))throw new Error('Invalid "handleExistingOrders" property in "createLimitOrder". Only "KEEP", "ERROR", "REPLACE", and "ADD" strings are supported. Defaults to "ADD".')})({side:t,amountInUSDT:r,entryPrice:n,handleExistingOrders:i,expirationInMinutes:a}),await o({main:e,side:t,entryPrice:n,handleExistingOrders:i});const s=await e.getContractInfo(),c=function(e,t,r,n){const{filters:o,quantityPrecision:i}=r,a=o.find((e=>"LOT_SIZE"===e.filterType)),s=parseFloat(a.minQty),c=parseFloat(a.maxQty),p=parseFloat(a.stepSize),d=o.find((e=>"MIN_NOTIONAL"===e.filterType)),l=parseFloat(d.notional);let u=e*t/n;if(u=parseFloat(u.toFixed(i)),u<s)throw new Error(`Quantity ${u} is below the minimum allowed: ${s}`);if(u>c)throw new Error(`Quantity ${u} exceeds the maximum allowed: ${c}`);u=Math.floor(u/p)*p;const y=u*n;if(y<l)throw new Error(`Notional value ${y} is below the minimum allowed: ${l}`);return u}(r,e.leverage,s,n),p={side:t,type:"LIMIT",quantity:c,price:n,timeInForce:"GTC"};if("number"==typeof a){a<=10&&(a=10.1);const t=60*a*1e3;let r=Date.now();e.useServerTime&&(r=await e.getServerTime()),p.goodTillDate=r+t,p.timeInForce="GTD"}return await e.fetch("order","POST",p)})({main:this,side:e,amountInUSDT:t,entryPrice:r,handleExistingOrders:n,expirationInMinutes:i})}async createTakeProfitOrder(e){return await(async(e,t)=>{const r=(await e.getPositions()).find((t=>t.symbol===e.contractName&&0!==parseFloat(t.positionAmt)));if(!r)throw new Error(`No open position found for ${e.contractName}`);const n=(await e.getOrders()).find((e=>"TAKE_PROFIT_MARKET"===e.origType));if(n){const t=await e.cancelOrder(n);e.debug&&console.log("createTakeProfitOrder canceled order",t)}const{entryPrice:o,positionAmt:i}=r,a=parseFloat(i)>0?"BUY":"SELL",s=await e.getContractInfo(),{tickSize:c}=s.filters.find((e=>"PRICE_FILTER"===e.filterType)),p=parseFloat((Math.round(t/c)*c).toFixed(s.pricePrecision));if("SELL"===a&&p>=parseFloat(o)||"BUY"===a&&p<=parseFloat(o))throw new Error(`Invalid take-profit price for ${a} position.`);const d={symbol:e.contractName,side:"BUY"===a?"SELL":"BUY",positionSide:"BOTH",type:"TAKE_PROFIT_MARKET",timeInForce:"GTE_GTC",quantity:0,stopPrice:p,workingType:"MARK_PRICE",closePosition:!0,placeType:"position",priceProtect:!0};return e.debug&&console.log("payload createTakeProfitOrder",d),await e.fetch("order","POST",d)})(this,e)}async createStopLossOrder(e){return await(async(e,t)=>{const r=(await e.getPositions()).find((t=>t.symbol===e.contractName&&0!==parseFloat(t.positionAmt)));if(!r)throw new Error(`No open position found for ${e.contractName}`);const n=(await e.getOrders()).find((e=>"STOP_MARKET"===e.origType));if(n){const t=await e.cancelOrder(n);e.debug&&console.log("createStopLossOrder canceled order",t)}const{entryPrice:o,positionAmt:i}=r,a=parseFloat(i)>0?"BUY":"SELL",s=await e.getContractInfo(),{tickSize:c}=s.filters.find((e=>"PRICE_FILTER"===e.filterType)),p=parseFloat((Math.round(t/c)*c).toFixed(s.pricePrecision));if("SELL"===a&&p<=parseFloat(o)||"BUY"===a&&p>=parseFloat(o))throw new Error(`Invalid stop-loss price for ${a} position.`);const d={symbol:e.contractName,side:"BUY"===a?"SELL":"BUY",positionSide:"BOTH",type:"STOP_MARKET",timeInForce:"GTE_GTC",quantity:0,stopPrice:p,workingType:"MARK_PRICE",closePosition:!0,placeType:"position",priceProtect:!0};return e.debug&&console.log("payload createStopLossOrder",d),await e.fetch("order","POST",d)})(this,e)}async changeMarginType(){return await this.fetch("marginType","POST",{marginType:this.marginType})}}})(),BinanceFutures=n})();