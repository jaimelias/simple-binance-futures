var BinanceFutures;(()=>{var e={262:()=>{}},r={};function t(n){var i=r[n];if(void 0!==i)return i.exports;var o=r[n]={exports:{}};return e[n](o,o.exports,t),o.exports}t.d=(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},t.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";t.r(n),t.d(n,{default:()=>s,defaultEndpoints:()=>a});const e=(e,r)=>{if(!("number"==typeof e&&e>=10))throw new Error('Invalid "triggerPrice" property in createStopLossOrder or createTakeProfitOrder. "triggerPrice" must be a positive number greater than 0.');if(!r||!["KEEP","ERROR","REPLACE"].includes(r))throw new Error('Invalid "handleExistingOrders" property in createStopLossOrder or createTakeProfitOrder. Only "KEEP", "ERROR", and "REPLACE" values are accepted.')};var r=t(262);const i=["time"],o=async({main:e,side:r,entryPrice:t,handleExistingOrders:n})=>{const i=(await e.getOrders()).filter((t=>t.symbol===e.contractName&&"LIMIT"===t.type&&t.side===r&&!1===t.reduceOnly&&!1===t.priceProtect&&!1===t.closePosition&&t.goodTillDate));if(i.length>0){if("KEEP"===n)return e.debug&&console.log(`New order (entryPrice=${t}, side=${r}) not executed. Found existing orders:`,i),!1;if("ERROR"===n)throw Error(`New order (entryPrice=${t}, side=${r}) not executed. Found duplicated orders: ${JSON.stringify(i)}`);if("REPLACE"===n){const r=await e.cancelMultipleOrders(i);e.debug&&console.log("cancelMultipleOrders",r)}else"ADD"===n&&e.debug&&console.log("Existing orders found. Pushing new order without deleting existing orders.")}return!0},a={testnet:"https://testnet.binancefuture.com",production:"https://fapi.binance.com"};class s{constructor(e,r){(e=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "strategy" must be a non-null object.');if(!e.hasOwnProperty("environment"))throw new Error('Missing "environment" property in strategy object.');if(!["testnet","production"].includes(e.environment))throw new Error('Invalid "environment" property. Only "testnet" and "production" are accepted.');if(!e.symbol)throw new Error('Invalid "symbol" property in strategy object.');if(!e.settlementCurrency)throw new Error('Invalid "symbol" property in strategy object.');if(!e.hasOwnProperty("leverage"))throw new Error('Missing "leverage" property in strategy object.');if(e.hasOwnProperty("marginType")&&("string"!=typeof e.marginType||!["ISOLATED","CROSSED"].includes(e.marginType)))throw new Error('Invalid "marginType" property in strategy object. Only "ISOLATED" and "CROSSED" margins are supported.');if(e.hasOwnProperty("useServerTime")&&"boolean"!=typeof e.useServerTime)throw new Error('Invalid "useServerTime" property in strategy object. Only boolean value is accepted');if(e.hasOwnProperty("debug")&&"boolean"!=typeof e.debug)throw new Error('Invalid "debug" property in strategy object. Only boolean value is accepted');const r=e.leverage;if("number"!=typeof r||isNaN(r)||r<=0)throw new Error('Invalid "leverage". It must be a positive number.')})(r);const{settlementCurrency:t,symbol:n,leverage:i,marginType:o="ISOLATED",environment:s,debug:c=!1,useServerTime:d=!1}=r;(e=>{if(!["testnet","production"].includes(e))throw new Error('Invalid environment. Allowed values are "testnet" and "production".')})(s),((e,r)=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "credentials" must be a non-null object.');if(!e.hasOwnProperty(r))throw new Error(`Missing credentials for environment: "${r}".`);const t=e[r];if(!t.hasOwnProperty("API_KEY"))throw new Error(`Missing "API_KEY" in credentials for environment "${r}".`);if(!t.hasOwnProperty("API_SECRET"))throw new Error(`Missing "API_SECRET" in credentials for environment "${r}".`)})(e,s);const{API_KEY:p,API_SECRET:l,PROXY:u}=e[s];this.API_KEY=p,this.API_SECRET=l,this.endpoint="string"==typeof u&&u.startsWith("http")?`${u}/fapi`:`${a[s]}/fapi`,this.contractName=`${n}${t}`,this.leverage=i,this.marginType=o,this.useServerTime=d,this.environment=s,this.debug=c,this.engine="undefined"!=typeof ScriptApp?"google-app-script":"undefined"!=typeof process&&"node"===process.release?.name?"node":"undefined"!=typeof Deno?"deno":"undefined"!=typeof Bun?"bun":"undefined"!=typeof WebSocketPair?"cloudflare-worker":"unknown",this.cache={}}async fetch(e,t="GET",n={},o="v1"){return await(async(e,t,n,o,a)=>{const s={...o,symbol:e.contractName};if(!i.includes(t)){let r=Date.now();e.useServerTime&&(r=await e.getServerTime()),s.timestamp=r,s.recvWindow=5e3}const c=`${e.endpoint}/${a}/${t}`,d=Object.entries(s).map((([e,r])=>`${e}=${encodeURIComponent(r)}`)).join("&"),p=((e,t)=>{const{engine:n,API_SECRET:i}=e;if("google-app-script"===n)return Utilities.computeHmacSha256Signature(t,i).map((e=>{const r=e+256&255;return(r<16?"0":"")+r.toString(16)})).join("");let o;if("object"==typeof r)o=r;else{if("object"!=typeof e.nodeCrypto)throw new Error('"crypto" library is not available in your global scope. you can pass "crypto" using the property "nodeCrypto" in your strategy');o=e.nodeCrypto}const a=o.createHmac("sha256",i);return a.update(t),a.digest("hex")})(e,d),l=i.includes(t)?d:`${d}&signature=${p}`,u=i.includes(t)?{}:{"X-MBX-APIKEY":e.API_KEY};let y;const f={method:n,headers:u};return"GET"===n||"DELETE"===n?y=`${c}?${l}`:(y=c,u["Content-Type"]="application/x-www-form-urlencoded","google-app-script"===e.engine?(f.payload=l,f.muteHttpExceptions=!0):f.body=l),"google-app-script"===e.engine?await(async(e,r)=>{const t=UrlFetchApp.fetch(e,r),n=t.getResponseCode(),i=t.getContentText();if(200===n)return JSON.parse(i);throw new Error(`Request failed with status ${n}: ${i}`)})(y,f):await(async(e,r,t)=>{let n;if("function"==typeof fetch)n=fetch;else{if("function"!=typeof e.nodeFetch)throw new Error('"fetch" library is not available in your global scope. you can pass "fetch" using the property "nodeFetch" in your strategy');n=e.nodeFetch}const i=await n(r,t),o=i.status,a=await i.text();if(200===o)return JSON.parse(a);throw new Error(`Request failed with status ${o}: ${a}`)})(e,y,f)})(this,e,t,n,o)}async getServerTime(){return(await this.fetch("time","GET",{})).serverTime}async getOrders(){return await this.fetch("openOrders","GET",{})}async getPositions(){return await this.fetch("positionRisk","GET",{},"v3")}async getBalance(e="USDT"){const r=(await this.fetch("balance","GET",{},"v2")).find((r=>r.asset===e));return"object"==typeof r?r.balance:0}async getContractInfo(){const{contractName:e}=this,r=`contract_${e}`;if(this.cache.hasOwnProperty(r))return this.cache[r];const t=(await this.fetch("exchangeInfo","GET",{})).symbols.find((r=>r.symbol===e));if(void 0===t)throw new Error(`contract ${e} not fund`);return this.cache[r]=t,t}async changeLeverage(){return await this.fetch("leverage","POST",{leverage:this.leverage})}async cancelMultipleOrders(e){const r=JSON.stringify(e.map((e=>e.orderId)));return await this.fetch("batchOrders","DELETE",{orderIdList:r})}async cancelOrder(e){const{orderId:r}=e;return await this.fetch("order","DELETE",{orderId:r})}async createLimitOrder({side:e,amountInUSD:r,entryPrice:t,handleExistingOrders:n,expirationInMinutes:i}){return await(async({main:e,side:r="BUY",amountInUSD:t,entryPrice:n,handleExistingOrders:i,expirationInMinutes:a=10})=>{(({side:e,amountInUSD:r,entryPrice:t,handleExistingOrders:n,expirationInMinutes:i})=>{if(!e||!["BUY","SELL"].includes(e))throw new Error('Invalid or missing property "side" in createLimitOrder.');if("number"!=typeof r||r<=0)throw new Error('Missing or invalid "amountInUSD" in createLimitOrder. "amountInUSD" must be a positive number.');if("number"!=typeof t||t<=0)throw new Error('Missing or invalid "entryPrice" in createLimitOrder. "entryPrice" must be a positive number.');if(void 0!==i&&!("number"==typeof i&&i>=10))throw new Error('Invalid "expirationInMinutes" in createLimitOrder. "expirationInMinutes" must be a positive number greater than or equal to 10.');if(!n||!["KEEP","ERROR","REPLACE","ADD"].includes(n))throw new Error('Invalid "handleExistingOrders" property in "createLimitOrder". Only "KEEP", "ERROR", "REPLACE", and "ADD" strings are supported. Defaults to "ADD".')})({side:r,amountInUSD:t,entryPrice:n,handleExistingOrders:i,expirationInMinutes:a}),await o({main:e,side:r,entryPrice:n,handleExistingOrders:i});const s=await e.getContractInfo(),c=function(e,r,t,n){const{filters:i,quantityPrecision:o}=t,a=i.find((e=>"LOT_SIZE"===e.filterType)),s=parseFloat(a.minQty),c=parseFloat(a.maxQty),d=parseFloat(a.stepSize),p=i.find((e=>"MIN_NOTIONAL"===e.filterType)),l=parseFloat(p.notional);let u=e*r/n;if(u=parseFloat(u.toFixed(o)),u<s)throw new Error(`Quantity ${u} is below the minimum allowed: ${s}`);if(u>c)throw new Error(`Quantity ${u} exceeds the maximum allowed: ${c}`);u=Math.floor(u/d)*d;const y=u*n;if(y<l)throw new Error(`Notional value ${y} is below the minimum allowed: ${l}`);return u}(t,e.leverage,s,n),d={side:r,type:"LIMIT",quantity:c,price:n,timeInForce:"GTC"};if("number"==typeof a){a<=10&&(a=10.1);const r=60*a*1e3;let t=Date.now();e.useServerTime&&(t=await e.getServerTime()),d.goodTillDate=t+r,d.timeInForce="GTD"}return await e.fetch("order","POST",d)})({main:this,side:e,amountInUSD:r,entryPrice:t,handleExistingOrders:n,expirationInMinutes:i})}async createTakeProfitOrder({triggerPrice:r,handleExistingOrders:t}){return await(async({main:r,triggerPrice:t,handleExistingOrders:n})=>{if(e(t,n),"KEEP"===n)return!1;const i="TAKE_PROFIT_MARKET",o=(await r.getPositions()).find((e=>e.symbol===r.contractName&&0!==parseFloat(e.positionAmt)));if(!o)throw new Error(`No open position found for ${r.contractName}`);await(async({main:e,handleExistingOrders:r,type:t})=>{if("KEEP"===r)return!0;if("ERROR"===r)throw new Error('New "take profit" order not execute because of an existing "take profit" order.');const n=(await e.getOrders()).find((e=>e.origType===t));if(n){const r=await e.cancelOrder(n);e.debug&&console.log("createTakeProfitOrder canceled order",r)}})({main:r,handleExistingOrders:n,type:i});const{entryPrice:a,positionAmt:s}=o,c=parseFloat(s)>0?"BUY":"SELL",d=await r.getContractInfo(),{tickSize:p}=d.filters.find((e=>"PRICE_FILTER"===e.filterType)),l=parseFloat((Math.round(t/p)*p).toFixed(d.pricePrecision));if("SELL"===c&&l>=parseFloat(a)||"BUY"===c&&l<=parseFloat(a))throw new Error(`Invalid take-profit price for ${c} position.`);const u={symbol:r.contractName,side:"BUY"===c?"SELL":"BUY",positionSide:"BOTH",type:i,timeInForce:"GTE_GTC",quantity:0,stopPrice:l,workingType:"MARK_PRICE",closePosition:!0,placeType:"position",priceProtect:!0};return r.debug&&console.log("payload createTakeProfitOrder",u),await r.fetch("order","POST",u)})({main:this,triggerPrice:r,handleExistingOrders:t})}async createStopLossOrder({triggerPrice:r,handleExistingOrders:t}){return await(async({main:r,triggerPrice:t,handleExistingOrders:n="REPLACE"})=>{if(e(t,n),"KEEP"===n)return!1;const i="STOP_MARKET",o=(await r.getPositions()).find((e=>e.symbol===r.contractName&&0!==parseFloat(e.positionAmt)));if(!o)throw new Error(`No open position found for ${r.contractName}`);await(async({main:e,handleExistingOrders:r,type:t})=>{if("KEEP"===r)return!0;if("ERROR"===r)throw new Error('New "take profit" order not execute because of an existing "take profit" order.');const n=(await e.getOrders()).find((e=>e.origType===t));if(n){const r=await e.cancelOrder(n);e.debug&&console.log("createStopLossOrder canceled order",r)}})({main:r,handleExistingOrders:n,type:i});const{entryPrice:a,positionAmt:s}=o,c=parseFloat(s)>0?"BUY":"SELL",d=await r.getContractInfo(),{tickSize:p}=d.filters.find((e=>"PRICE_FILTER"===e.filterType)),l=parseFloat((Math.round(t/p)*p).toFixed(d.pricePrecision));if("SELL"===c&&l<=parseFloat(a)||"BUY"===c&&l>=parseFloat(a))throw new Error(`Invalid stop-loss price for ${c} position.`);const u={symbol:r.contractName,side:"BUY"===c?"SELL":"BUY",positionSide:"BOTH",type:i,timeInForce:"GTE_GTC",quantity:0,stopPrice:l,workingType:"MARK_PRICE",closePosition:!0,placeType:"position",priceProtect:!0};return r.debug&&console.log("payload createStopLossOrder",u),await r.fetch("order","POST",u)})({main:this,triggerPrice:r,handleExistingOrders:t})}async changeMarginType(){return await this.fetch("marginType","POST",{marginType:this.marginType})}}})(),BinanceFutures=n})();