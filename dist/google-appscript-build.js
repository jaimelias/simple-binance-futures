var BinanceFutures;(()=>{"use strict";var e={d:(r,t)=>{for(var i in t)e.o(t,i)&&!e.o(r,i)&&Object.defineProperty(r,i,{enumerable:!0,get:t[i]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};(()=>{e.r(r),e.d(r,{default:()=>p,defaultEndpoints:()=>d});const t=(e,r)=>{if(!("number"==typeof e&&e>=10))throw new Error('Invalid "triggerPrice" property in createStopLossOrder or createTakeProfitOrder. "triggerPrice" must be a positive number greater than 0.');if(!r||!["KEEP","ERROR","REPLACE"].includes(r))throw new Error('Invalid "handleExistingOrders" property in createStopLossOrder or createTakeProfitOrder. Only "KEEP", "ERROR", and "REPLACE" values are accepted.')},i={200:"OK",201:"Created",400:"Bad Request",401:"Unauthorized",403:"Forbidden",404:"Not Found",500:"Internal Server Error"},n=["time"];function o(e,r,t,i){const{filters:n,quantityPrecision:o}=t,a=n.find((e=>"LOT_SIZE"===e.filterType)),s=parseFloat(a.minQty),c=parseFloat(a.maxQty),l=parseFloat(a.stepSize),d=n.find((e=>"MIN_NOTIONAL"===e.filterType)),p=parseFloat(d.notional);let u=e*r/i;if(u<s)throw new Error(`Quantity ${u} is below the minimum allowed: ${s}`);if(u>c)throw new Error(`Quantity ${u} exceeds the maximum allowed: ${c}`);u=Math.floor(u/l)*l;const y=u*i;if(y<p)throw new Error(`Notional value ${y} is below the minimum allowed: ${p}`);return u=parseFloat(u.toFixed(o)),u}const a=e=>{const r=new Date(e),t=e=>e<10?`0${e}`:e;return`${r.getFullYear()}-${t(r.getMonth()+1)}-${t(r.getDate())} ${t(r.getHours())}:${t(r.getMinutes())}:${t(r.getSeconds())}`},s=async({main:e,expirationInMinutes:r})=>{const t={timeInForce:null,goodTillDate:null};if("number"==typeof r){r<=10&&(r=10.1);const i=60*r*1e3;let n=Date.now();e.useServerTime&&(n=await e.getServerTime()),t.goodTillDate=n+i,t.timeInForce="GTD"}return t};class c{constructor(e={}){this.errorLogger=e.hasOwnProperty("errorLogger")&&"function"==typeof e.errorLogger?e.errorLogger:null}async init(e){try{return await e()}catch(e){throw"function"==typeof this.errorLogger&&await this.errorLogger(e.message),new Error(e.message)}}}const l=e=>{if(null===e||"object"!=typeof e||Array.isArray(e))return JSON.stringify(e);let r="\n\n---\n\n";for(const[t,i]of Object.entries(e))if(null!==i&&"object"==typeof i)try{r+=`${t}: ${JSON.stringify(i)}\n`}catch(e){r+=`${t}: [Unable to stringify value]\n`}else r+=`${t}: ${i}\n`;return r},d={testnet:"https://testnet.binancefuture.com",production:"https://fapi.binance.com"};class p{constructor(e,r,t){this.engine="undefined"!=typeof ScriptApp?"google-app-script":"undefined"!=typeof process&&"node"===process.release?.name?"node":"undefined"!=typeof Deno?"deno":"undefined"!=typeof Bun?"bun":"undefined"!=typeof WebSocketPair?"cloudflare-worker":"unknown",((e={},r)=>{if("object"!=typeof e)throw new Error('Invalid type: "callbacks" property must be an object.');if(e.hasOwnProperty("errorLogger")&&"function"!=typeof e.errorLogger)throw new Error('Invalid type: "callbacks.errorLogger" must be a callback function.');if("google-app-script"!==r){if(!e.hasOwnProperty("fetch"))throw new Error(`The current engine "${r}" requires "fetch" to be provided as a parameter in callbacks.`);if("function"!=typeof e.fetch&&"object"!=typeof e.fetch)throw new Error('Invalid type: "callbacks.fetch" must be a standard Fetch API callback.');if(!e.hasOwnProperty("crypto"))throw new Error(`The current engine "${r}" requires "crypto" to be provided as a parameter in callbacks.`);if("function"!=typeof e.crypto&&"object"!=typeof e.crypto)throw new Error("Invalid type: \"callbacks.crypto\" must be a standard Web Crypto API callback. Use globalThis.crypto or require('node:crypto').webcrypto or import crypto from 'node:crypto' to access this module.")}})(t,this.engine),(e=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "strategy" must be a non-null object.');if(!e.hasOwnProperty("environment"))throw new Error('Missing "environment" property in strategy object.');if(!["testnet","production"].includes(e.environment))throw new Error('Invalid "environment" property. Only "testnet" and "production" are accepted.');if(!e.symbol)throw new Error('Invalid "symbol" property in strategy object.');if(!e.settlementCurrency)throw new Error('Invalid "symbol" property in strategy object.');if(e.hasOwnProperty("marginType")&&("string"!=typeof e.marginType||!["ISOLATED","CROSSED"].includes(e.marginType)))throw new Error('Invalid "marginType" property in strategy object. Only "ISOLATED" and "CROSSED" margins are supported.');if(e.hasOwnProperty("useServerTime")&&"boolean"!=typeof e.useServerTime)throw new Error('Invalid "useServerTime" property in strategy object. Only boolean value is accepted');if(e.hasOwnProperty("debug")&&"boolean"!=typeof e.debug)throw new Error('Invalid "debug" property in strategy object. Only boolean value is accepted');if(e.hasOwnProperty("useMarkPrice")&&"boolean"!=typeof e.useMarkPrice)throw new Error('Invalid "useMarkPrice" property in strategy object. Only boolean value is accepted');if(e.hasOwnProperty("leverageBracket")&&("object"!=typeof e.leverageBracket||!e.leverageBracket.hasOwnProperty("brackets")))throw new Error('Invalid "leverageBracket" property in strategy object. Only objects with the property "brackets" are accepted.');if(e.hasOwnProperty("contractInfo")&&("object"!=typeof e.contractInfo||!e.contractInfo.hasOwnProperty("symbol")))throw new Error('Invalid "contractInfo" property in strategy object. Only objects with the property "symbol" are accepted.');if(e.hasOwnProperty("balance")&&"number"!=typeof e.balance)throw new Error('Invalid "balance" property in strategy object. Only numbers are accepted.')})(r),this.callbacks=t,this.errorHandler=new c(this.callbacks);const{settlementCurrency:i,symbol:n,marginType:o="ISOLATED",environment:a,debug:s=!1,useServerTime:l=!1,useMarkPrice:p=!1,leverageBracket:u={},exchangeInfo:y={},contractInfo:h={},balance:m=0}=r;(e=>{if(!["testnet","production"].includes(e))throw new Error('Invalid environment. Allowed values are "testnet" and "production".')})(a),((e,r)=>{if("object"!=typeof e||null===e)throw new Error('Invalid type: "credentials" must be a non-null object.');if(!e.hasOwnProperty(r))throw new Error(`Missing credentials for environment: "${r}".`);const t=e[r];if(!t.hasOwnProperty("API_KEY"))throw new Error(`Missing "API_KEY" in credentials for environment "${r}".`);if(!t.hasOwnProperty("API_SECRET"))throw new Error(`Missing "API_SECRET" in credentials for environment "${r}".`)})(e,a);const{API_KEY:g,API_SECRET:f,PROXY:w}=e[a];this.API_KEY=g,this.API_SECRET=f,this.endpoint="string"==typeof w&&w.startsWith("http")?`${w}/fapi`:`${d[a]}/fapi`,this.settlementCurrency=i,this.contractName=`${n}${i}`,this.marginType=o,this.useServerTime=l,this.environment=a,this.debug=s,this.workingType=p?"MARK_PRICE":"CONTRACT_PRICE",this.exchangeInfo=y,this.leverageBracket=u,this.contractInfo=h,this.balance=m,this.leverage=null,this.latestPrice=0}async fetch(e,r="GET",t={},o="v1"){return await(async(e,r,t,o,a)=>{const s={...o,symbol:e.contractName};if(!n.includes(r)){let r=Date.now();e.useServerTime&&(r=await e.getServerTime()),s.timestamp=r,s.recvWindow=5e3}const c=`${e.endpoint}/${a}/${r}`,l=Object.entries(s).map((([e,r])=>`${e}=${encodeURIComponent(r)}`)).join("&"),d=((e,r)=>{const{engine:t,API_SECRET:i}=e;if("google-app-script"===t)return Utilities.computeHmacSha256Signature(r,i).map((e=>{const r=e+256&255;return(r<16?"0":"")+r.toString(16)})).join("");const{crypto:n}=e.callbacks,o=n.createHmac("sha256",i);return o.update(r),o.digest("hex")})(e,l),p=n.includes(r)?l:`${l}&signature=${d}`,u=n.includes(r)?{}:{"X-MBX-APIKEY":e.API_KEY};let y;const h={method:t,headers:u};return"GET"===t||"DELETE"===t?y=`${c}?${p}`:(y=c,u["Content-Type"]="application/x-www-form-urlencoded","google-app-script"===e.engine?(h.payload=p,h.muteHttpExceptions=!0):h.body=p),"google-app-script"===e.engine?await(async(e,r)=>{const t=UrlFetchApp.fetch(e,r),n=t.getResponseCode(),o=t.getContentText();if(200===n)return JSON.parse(o);const a=i[n]||"Unknown Status";throw new Error(`Request failed with status ${a?`${n} (${a})`:n}. Body: ${o}`)})(y,h):await(async(e,r,t)=>{const{fetch:i}=e.callbacks,n=await i(r,t),{status:o,statusText:a}=n,s=await n.text();if(200===o)return JSON.parse(s);throw new Error(`Request failed with status ${a?`${o} (${a})`:o}. Body: ${s}`)})(e,y,h)})(this,e,r,t,o)}async getServerTime(){return this.errorHandler.init((async()=>(await this.fetch("time","GET",{})).serverTime))}async getOrders(){return this.errorHandler.init((async()=>await this.fetch("openOrders","GET",{})))}async getParsedOrders(){const e={orders:{BUY:[],SELL:[]},sl:{BUY:[],SELL:[]},tp:{BUY:[],SELL:[]}},r=await this.getOrders();for(const t of r){const{type:r,side:i,reduceOnly:n,closePosition:o}=t;["MARKET","LIMIT","STOP"].includes(r)&&!1===n&&!1===o?e.orders[i].push(t):"STOP_MARKET"===r&&n&&o?e.sl[i].push(t):"TAKE_PROFIT_MARKET"===r&&n&&o&&e.tp[i].push(t)}return e}async getPositions(){return this.errorHandler.init((async()=>await this.fetch("positionRisk","GET",{},"v3")))}async getParsedPositions(){const e={BUY:[],SELL:[]},r=await this.getPositions();for(const t of r){const r=parseFloat(t.positionAmt);r>0&&e.BUY.push(t),r<0&&e.SELL.push(t)}return e}async getBalance(e=!0){return this.errorHandler.init((async()=>{if(!1===e&&this.balance)return this.balance;const r=(await this.fetch("balance","GET",{},"v2")).find((e=>e.asset===this.settlementCurrency));if("object"==typeof r){const t=parseFloat(r.balance);return e&&(this.balance=t),t}return 0}))}async getExchangeInfo(){return this.errorHandler.init((async()=>("object"==typeof this.exchangeInfo&&this.exchangeInfo.hasOwnProperty("symbols")||(this.exchangeInfo=await this.fetch("exchangeInfo","GET",{})),this.exchangeInfo)))}async getContractInfo(){return this.errorHandler.init((async()=>{const{contractName:e}=this;if(this.contractInfo.hasOwnProperty("symbol"))return this.contractInfo;const r=(await this.getExchangeInfo()).symbols.find((r=>r.symbol===e));if(void 0===r)throw new Error(`contract ${e} not fund`);return this.contractInfo=r,r}))}async changeLeverage(e,r){return this.errorHandler.init((async()=>{if("number"!=typeof e&&e!==1/0||Number.isNaN(e)||e<=0)throw new Error('Invalid "leverageParam". It must be a positive number greater than 0 in "changeLeverage".');const t=await this.getMaxLevarage(r),i=Math.floor(Math.min(e,t));return this.leverage=i,await this.fetch("leverage","POST",{leverage:i}),i}))}async cancelMultipleOrders(e){return this.errorHandler.init((async()=>{const r=JSON.stringify(e.map((e=>e.orderId)));return await this.fetch("batchOrders","DELETE",{orderIdList:r})}))}async cancelOrder(e){return this.errorHandler.init((async()=>{const{orderId:r}=e;return await this.fetch("order","DELETE",{orderId:r})}))}async createLimitOrder({side:e,amountInUSD:r,entryPrice:t,handleExistingOrders:i,expirationInMinutes:n,orders:a,ignoreImmediateExecErr:c}){return this.errorHandler.init((async()=>await(async({main:e,side:r="BUY",amountInUSD:t,entryPrice:i,handleExistingOrders:n,expirationInMinutes:a=10,orders:c,ignoreImmediateExecErr:d=!1})=>{if(0===e.latestPrice&&await e.ohlcv({interval:"5m",limit:1,klineType:"CONTRACT_PRICE"===e.workingType?"indexPriceKlines":"markPriceKlines"}),(({main:e,side:r,amountInUSD:t,entryPrice:i,handleExistingOrders:n,expirationInMinutes:o,ignoreImmediateExecErr:a})=>{if(!e.leverage||"number"!=typeof e.leverage)throw new Error("Before executing createLimitOrder, execute changeLeverage(leverage, amountInUsd). ");if(!r||!["BUY","SELL"].includes(r))throw new Error('Invalid or missing property "side" in createLimitOrder.');if("number"!=typeof t||t<=0)throw new Error('Missing or invalid "amountInUSD" in createLimitOrder. "amountInUSD" must be a positive number.');if("number"!=typeof i||i<=0)throw new Error('Missing or invalid "entryPrice" in createLimitOrder. "entryPrice" must be a positive number.');if(void 0!==o&&!("number"==typeof o&&o>=10))throw new Error('Invalid "expirationInMinutes" in createLimitOrder. "expirationInMinutes" must be a positive number greater than or equal to 10.');if(!n||!["KEEP","ERROR","REPLACE","ADD"].includes(n))throw new Error('Invalid "handleExistingOrders" property in "createLimitOrder". Only "KEEP", "ERROR", "REPLACE", and "ADD" strings are supported. Defaults to "ADD".');if("boolean"!=typeof a)throw new Error('Invalid property "side" in "ignoreImmediateExecErr". "ignoreImmediateExecErr" must be a boolean.');if(!1===a&&e.hasOwnProperty("latestPrice")&&e.latestPrice>0){if("BUY"===r&&i>e.latestPrice)throw new Error(`Immediate order execution error. In "createLimitOrder" side "BUY" the "entryPrice" (${i}) must be less than the latest close price (${e.latestPrice}).`);if("SELL"===r&&i<e.latestPrice)throw new Error(`Immediate order execution error. In "createLimitOrder" side "SELL" the "entryPrice" (${i}) must be greater than the latest close price (${e.latestPrice}).`)}})({main:e,side:r,amountInUSD:t,entryPrice:i,handleExistingOrders:n,expirationInMinutes:a,ignoreImmediateExecErr:d}),await(async({main:e,side:r,entryPrice:t,handleExistingOrders:i,orders:n})=>{n||(n=await e.getOrders());const o=n.filter((t=>t.symbol===e.contractName&&"LIMIT"===t.type&&t.side===r&&!1===t.reduceOnly&&!1===t.priceProtect&&!1===t.closePosition&&t.goodTillDate));if(o.length>0){if("KEEP"===i)return e.debug&&console.log(`New order (entryPrice=${t}, side=${r}) not executed. Found existing orders:`,o),!0;if("ERROR"===i)throw Error(`New order (entryPrice=${t}, side=${r}) not executed. Found duplicated orders: ${JSON.stringify(o)}`);if("REPLACE"===i){const r=await e.cancelMultipleOrders(o);e.debug&&console.log("cancelMultipleOrders",r)}else"ADD"===i&&e.debug&&console.log("Existing orders found. Pushing new order without deleting existing orders.")}return!1})({main:e,side:r,entryPrice:i,handleExistingOrders:n,orders:c}))return console.log('Ignoring create limit order because of "KEEP".'),!1;const{contractName:p,leverage:u}=e,y=await e.getContractInfo(),h=o(t,u,y,i),{tickSize:m}=y.filters.find((e=>"PRICE_FILTER"===e.filterType)),g=parseFloat((Math.round(i/m)*m).toFixed(y.pricePrecision)),f={side:r,type:"LIMIT",quantity:h,price:g,timeInForce:"GTC",closePosition:!1,reduceOnly:!1},{timeInForce:w,goodTillDate:E}=await s({main:e,expirationInMinutes:a});w&&E&&Object.assign(f,{timeInForce:w,goodTillDate:E});const P=await e.fetch("order","POST",f);if(e.debug&&console.log("createLimitOrder",{payload:f,response:P}),!P.hasOwnProperty("orderId"))throw new Error(`Error in createLimitOrder: ${l({contractName:p,leverage:u,amountInUSD:t,...P,entryPrice:i,adjustedEntryPrice:g,side:r,quantity:h,tickSize:m})}`);return P})({main:this,side:e,amountInUSD:r,entryPrice:t,handleExistingOrders:i,expirationInMinutes:n,orders:a,ignoreImmediateExecErr:c})))}async modifyLimitOrder({orders:e,entryPrice:r,side:t,expirationInMinutes:i}){return this.errorHandler.init((async()=>await(async({main:e,orders:r=[],entryPrice:t,side:i,expirationInMinutes:n=10})=>{if(isNaN(t)||t<=0)throw new Error('"entryPrice" must be a positive number.');if(n&&(isNaN(n)||n<10))throw new Error('"expirationInMinutes" must be a positive number greater than 10.');if(!["SELL","BUY"].includes(i))throw new Error('"side" must be either "SELL" or "BUY".');if(!Array.isArray(r))throw new Error('"orders" must be a valid array.');0===r.length&&(r=await e.getOrders());const{contractName:o}=e,a=!!Array.isArray(r)&&r.find((e=>e.symbol===o&&"LIMIT"===e.type&&(e=>{const{origQty:r,executedQty:t}=e,n=parseFloat(r)-parseFloat(t);if(0!==n){if(n>0&&"BUY"===i)return!0;if(n<0&&"SELL"===i)return!0}return!1})(e))),{orderId:c,origQty:d,executedQty:p,price:u}=a;if(!c||isNaN(d)||isNaN(p))throw new Error('"order" must contain valid orderId, origQty, and executedQty properties.');const y=parseFloat(d)-parseFloat(p);if(y<=0)throw new Error("Remaining quantity must be greater than zero.");const h=await e.getContractInfo(),{tickSize:m}=h.filters.find((e=>"PRICE_FILTER"===e.filterType)),g=e=>(e=parseFloat(e),parseFloat((Math.round(e/m)*m).toFixed(h.pricePrecision))),f=g(t);if(f===g(u))return!1;const w={orderId:c,quantity:y,price:f,side:i,type:"LIMIT",timeInForce:"GTC"},{timeInForce:E,goodTillDate:P}=await s({main:e,expirationInMinutes:n});E&&P&&Object.assign(w,{timeInForce:E,goodTillDate:P});const b=await e.fetch("order","PUT",w);if(e.debug&&console.log("modifyLimitOrder",{payload:w,response:b}),!b.hasOwnProperty("orderId"))throw new Error(`Error in modifyLimitOrder: ${l({contractName:o,...b,entryPrice:t,adjustedEntryPrice:f,side:i,quantity:y,tickSize:m})}`);return b})({main:this,orders:e,entryPrice:r,side:t,expirationInMinutes:i})))}async createStopLimitOrder({side:e,amountInUSD:r,stopPrice:t,limitPrice:i,handleExistingOrders:n,expirationInMinutes:a,orders:c}){return this.errorHandler.init((async()=>await(async({main:e,side:r="BUY",amountInUSD:t,stopPrice:i,limitPrice:n,handleExistingOrders:a,expirationInMinutes:c=10,orders:d})=>{if(0===e.latestPrice&&await e.ohlcv({interval:"5m",limit:1,klineType:"CONTRACT_PRICE"===e.workingType?"indexPriceKlines":"markPriceKlines"}),(({main:e,side:r,amountInUSD:t,stopPrice:i,limitPrice:n,handleExistingOrders:o,expirationInMinutes:a})=>{if(!e.leverage||"number"!=typeof e.leverage)throw new Error("Before executing createLimitOrder, execute changeLeverage(leverage, amountInUsd). ");if(!r||!["BUY","SELL"].includes(r))throw new Error('Invalid or missing property "side" in validateStopLimitOrder.');if("number"!=typeof t||t<=0)throw new Error('Missing or invalid "amountInUSD" in createStopLimitOrder. "amountInUSD" must be a positive number.');if("number"!=typeof i||i<=0)throw new Error('Missing or invalid "stopPrice" in createStopLimitOrder. "stopPrice" must be a positive number.');if("number"!=typeof n||n<=0)throw new Error('Missing or invalid "limitPrice" in createStopLimitOrder. "limitPrice" must be a positive number.');if(void 0!==a&&!("number"==typeof a&&a>=10))throw new Error('Invalid "expirationInMinutes" in createStopLimitOrder. "expirationInMinutes" must be a positive number greater than or equal to 10.');if(!o||!["KEEP","ERROR","REPLACE","ADD"].includes(o))throw new Error('Invalid "handleExistingOrders" property in "createStopLimitOrder". Only "KEEP", "ERROR", "REPLACE", and "ADD" strings are supported. Defaults to "ADD".');if(e.hasOwnProperty("latestPrice")&&e.latestPrice>0){if("BUY"===r&&i<e.latestPrice)throw new Error(`Immediate order execution error. In "createStopLimitOrder" side "BUY" the "entryPrice" (${i}) must be greater than the latest close price (${e.latestPrice}).`);if("SELL"===r&&i>e.latestPrice)throw new Error(`Immediate order execution error. In "createStopLimitOrder" side "SELL" the "entryPrice" (${i}) must be less than the latest close price (${e.latestPrice}).`)}})({main:e,side:r,amountInUSD:t,stopPrice:i,limitPrice:n,handleExistingOrders:a,expirationInMinutes:c}),await(async({main:e,side:r,stopPrice:t,limitPrice:i,handleExistingOrders:n,orders:o})=>{o||(o=await e.getOrders());const a=o.filter((t=>t.symbol===e.contractName&&"STOP"===t.type&&t.side===r&&!1===t.reduceOnly&&!1===t.priceProtect&&!1===t.closePosition&&t.goodTillDate));if(a.length>0){if("KEEP"===n)return e.debug&&console.log(`New order (stopPrice=${t}, limitPrice=${i} side=${r}) not executed. Found existing orders:`,a),!0;if("ERROR"===n)throw Error(`New order (stopPrice=${t}, limitPrice=${i} side=${r}) not executed. Found duplicated orders: ${JSON.stringify(a)}`);if("REPLACE"===n){const r=await e.cancelMultipleOrders(a);e.debug&&console.log("cancelMultipleOrders",r)}else"ADD"===n&&e.debug&&console.log("Existing orders found. Pushing new order without deleting existing orders.")}return!1})({main:e,side:r,stopPrice:i,limitPrice:n,handleExistingOrders:a,orders:d}))return console.log('Ignoring create limit order because of "KEEP".'),!1;const p=await e.getContractInfo(),{contractName:u,leverage:y}=e,h=o(t,y,p,n),{tickSize:m}=p.filters.find((e=>"PRICE_FILTER"===e.filterType)),g={side:r,type:"STOP",quantity:h,stopPrice:parseFloat((Math.round(i/m)*m).toFixed(p.pricePrecision)),price:parseFloat((Math.round(n/m)*m).toFixed(p.pricePrecision)),timeInForce:"GTC",workingType:e.workingType,closePosition:!1,reduceOnly:!1},{timeInForce:f,goodTillDate:w}=await s({main:e,expirationInMinutes:c});f&&w&&Object.assign(g,{timeInForce:f,goodTillDate:w});const E=await e.fetch("order","POST",g);if(e.debug&&console.log("createStopLimitOrder",{payload:g,response:E}),!E.hasOwnProperty("orderId"))throw new Error(`Error in createStopLimitOrder: ${l({contractName:u,leverage:y,amountInUSD:t,...E,stopPrice:i,limitPrice:n,side:r,quantity:h,tickSize:m})}`);return E})({main:this,side:e,amountInUSD:r,stopPrice:t,limitPrice:i,handleExistingOrders:n,expirationInMinutes:a,orders:c})))}async createTakeProfitOrder({triggerPrice:e,handleExistingOrders:r,positions:i,orders:n}){return this.errorHandler.init((async()=>await(async({main:e,triggerPrice:r,handleExistingOrders:i,positions:n,orders:o,workingType:a="MARK_PRICE"})=>{t(r,i);const s="TAKE_PROFIT_MARKET";n||(n=await e.getPositions());const c=n.find((r=>r.symbol===e.contractName&&0!==parseFloat(r.positionAmt)));if(!c)throw new Error(`No open position found for ${e.contractName} in createTakeProfitOrder`);if(await(async({main:e,handleExistingOrders:r,type:t,orders:i,triggerPrice:n})=>{i||(i=await e.getOrders());const o=i.find((e=>e.origType===t));if(o){if("KEEP"===r)return!0;if("ERROR"===r)throw new Error('New "take profit" order not execute because of an existing "take profit" order.');if(parseFloat(o.stopPrice)===n)return!0;const t=await e.cancelOrder(o);e.debug&&console.log("createTakeProfitOrder canceled order",t)}return!1})({main:e,handleExistingOrders:i,type:s,orders:o,triggerPrice:r}))return console.log('Ignoring take profit order because of "KEEP".'),!0;const{contractName:d}=e,{entryPrice:p,positionAmt:u}=c,y=parseFloat(u)>0?"BUY":"SELL",h=await e.getContractInfo(),{tickSize:m}=h.filters.find((e=>"PRICE_FILTER"===e.filterType)),g=parseFloat((Math.round(r/m)*m).toFixed(h.pricePrecision));if("SELL"===y&&g>=parseFloat(p)||"BUY"===y&&g<=parseFloat(p))throw await e.closePosition({positions:n,side:y}),new Error(`Invalid take-profit triggerPrice "${r}" for ${y} position forced to close position.`);const f={symbol:d,side:"BUY"===y?"SELL":"BUY",positionSide:"BOTH",type:s,timeInForce:"GTE_GTC",quantity:0,stopPrice:g,workingType:e.workingType,closePosition:!0,placeType:"position",priceProtect:!0,workingType:a},w=await e.fetch("order","POST",f);if(e.debug&&console.log("payload createTakeProfitOrder",{payload:f,response:w}),!w.hasOwnProperty("orderId"))throw await e.closePosition({positions:n,side:y}),new Error(`Error in createTakeProfitOrder forced to close position: ${l({contractName:d,...w,side:y,triggerPrice:r,adjustedStopPrice:g,tickSize:m})}`);return w})({main:this,triggerPrice:e,handleExistingOrders:r,positions:i,orders:n})))}async createStopLossOrder({triggerPrice:e,handleExistingOrders:r,positions:i,orders:n}){return this.errorHandler.init((async()=>await(async({main:e,triggerPrice:r,handleExistingOrders:i="REPLACE",positions:n,orders:o})=>{t(r,i);const a="STOP_MARKET";n||(n=await e.getPositions());const s=n.find((r=>r.symbol===e.contractName&&0!==parseFloat(r.positionAmt)));if(!s)throw new Error(`No open position found for ${e.contractName} in createStopLossOrder`);if(await(async({main:e,handleExistingOrders:r,type:t,orders:i,triggerPrice:n})=>{i||(i=await e.getOrders());const o=i.find((e=>e.origType===t));if(o){if("KEEP"===r)return!0;if("ERROR"===r)throw new Error('New "take profit" order not execute because of an existing "take profit" order.');if(parseFloat(o.stopPrice)===n)return!0;const t=await e.cancelOrder(o);e.debug&&console.log("createStopLossOrder canceled order",t)}return!1})({main:e,handleExistingOrders:i,type:a,orders:o,triggerPrice:r}))return console.log('Ignoring stop loss order because of "KEEP".'),!0;const{contractName:c,workingType:d}=e,{entryPrice:p,positionAmt:u}=s,y=parseFloat(u)>0?"BUY":"SELL",h=await e.getContractInfo(),{tickSize:m}=h.filters.find((e=>"PRICE_FILTER"===e.filterType)),g=parseFloat((Math.round(r/m)*m).toFixed(h.pricePrecision));if("SELL"===y&&g<=parseFloat(p)||"BUY"===y&&g>=parseFloat(p))throw await e.closePosition({positions:n,side:y}),new Error(`Invalid stop-loss triggerPrice "${r}" for ${y} position forced to close position.`);const f={symbol:c,side:"BUY"===y?"SELL":"BUY",positionSide:"BOTH",type:a,timeInForce:"GTE_GTC",quantity:0,stopPrice:g,workingType:d,closePosition:!0,placeType:"position",priceProtect:!0},w=await e.fetch("order","POST",f);if(e.debug&&console.log("createStopLossOrder",{payload:f,response:w}),!w.hasOwnProperty("orderId"))throw await e.closePosition({positions:n,side:y}),new Error(`Error in createStopLossOrder forced to close position: ${l({contractName:c,...w,side:y,triggerPrice:r,adjustedStopPrice:g,tickSize:m})}`);return w})({main:this,triggerPrice:e,handleExistingOrders:r,positions:i,orders:n})))}async changeMarginType(){return this.errorHandler.init((async()=>await this.fetch("marginType","POST",{marginType:this.marginType})))}async ohlcv(e){if(Array.isArray(e)){const r={};for(const t of e)r[t.interval]=await this.ohlcv(t);return r}const{interval:r,startTime:t,endTime:i,limit:n,klineType:o="klines"}=e;return await this.errorHandler.init((async()=>{(({interval:e,limit:r,startTime:t,endTime:i,klineType:n})=>{const o=["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"],a=e=>null==e,s=e=>e instanceof Date?new Date(e.getTime()):"number"==typeof e||"string"==typeof e?new Date(e):new Date(NaN);if(a(e)||!o.includes(e))throw new Error(`Invalid "interval". Accepted values are: ${o.join(", ")}.`);const c=["klines","continuousKlines","indexPriceKlines","markPriceKlines","premiumIndexKlines"];if("string"!=typeof n||!c.includes(n))throw new Error(`Invalid "klineType". Accepted values are: ${c.join(", ")}.`);const l=!a(r),d=!a(t),p=!a(i);if(l&&(d||p))throw new Error('"ohlcv" does not accept "limit" together with "startTime" or "endTime".');if(!(l||d&&p))throw new Error('"ohlcv" requires either "limit" or both "startTime" and "endTime".');if(l){if("number"!=typeof r||!Number.isFinite(r)||r<1||r>1500)throw new Error('"limit" must be a finite number between 1 and 1500 (inclusive).');return!0}const u=s(t),y=s(i);if(Number.isNaN(u.getTime()))throw new Error('"startTime" is not a valid date/time.');if(Number.isNaN(y.getTime()))throw new Error('"endTime" is not a valid date/time.');if(u.getTime()>=y.getTime())throw new Error('"startTime" must be earlier than "endTime".')})({interval:r,startTime:t,endTime:i,limit:n,klineType:o});const{contractName:e}=this,s={interval:r,pair:e,...n?{limit:n}:{startTime:t,endTime:i}},c=await this.fetch(o,"GET",s);if(!Array.isArray(c))throw new Error('Invalid response in "ohlcv".');if(!Array.isArray(c[0]))throw new Error('Invalid response in "ohlcv".');const l=["klines","continuousKlines"].includes(o),d=c.length,p=new Array(d);for(let e=0;e<d;e++){const[r,t,i,n,o,s]=c[e],d={open:+t,high:+i,low:+n,close:+o,date:a(r)};l&&(d.volume=+s),p[e]=d}return this.latestPrice=p[p.length-1].close,p}))}async cancelAllOpenedOrders(){return this.errorHandler.init((async()=>await this.fetch("allOpenOrders","DELETE")))}async closePosition({positions:e,side:r}){return this.errorHandler.init((async()=>await(async({main:e,positions:r,side:t})=>{if(!["SELL","BUY"].includes(t))throw new Error('Invalid "side" property in closePosition. Only "SELL" or "BUY" buy is accepted.');r||(r=await e.getPositions());const i=r.find((r=>r.symbol===e.contractName&&(e=>{const r=parseFloat(e.positionAmt);if(0!==r){if(r>0&&"BUY"===t)return!0;if(r<0&&"SELL"===t)return!0}return!1})(r)));if(!i)throw new Error(`No open position found for ${e.contractName} in closePosition`);const n=Math.abs(parseFloat(i.positionAmt)),o={symbol:e.contractName,side:"BUY"===t?"SELL":"BUY",type:"MARKET",quantity:n,reduceOnly:!0,isolated:"ISOLATED"===e.marginType,placeType:"position",positionSide:"BOTH"},a=await e.fetch("order","POST",o);return e.debug&&console.log("closePosition",{payload:o,response:a}),a})({main:this,positions:e,side:r})))}async getLeverageBracket(){return this.errorHandler.init((async()=>{if("object"==typeof this.leverageBracket&&this.leverageBracket.hasOwnProperty("brackets"))return this.leverageBracket;const e=await this.fetch("leverageBracket","GET");if(!Array.isArray(e)||0===e.length||!Array.isArray(e[0].brackets)||0===e[0].brackets.length)throw new Error(`Leverage bracket data not available for contractName: ${this.contractName}`);return this.leverageBracket=e[0],this.leverageBracket}))}async getMaxLevarage(e){return this.errorHandler.init((async()=>{if("number"!=typeof e||Number.isNaN(e))throw new Error('Param "notional" must be a number in the settlement currency of the contract.');const r=await this.getLeverageBracket(),t=r.notionalCoef??1,i=e*t,n=r.brackets;for(const e of n)if(i>=e.notionalFloor&&i<e.notionalCap)return e.initialLeverage;const o=n[n.length-1];return{maxLeverage:o?.initialLeverage??null}}))}}})(),BinanceFutures=r})();